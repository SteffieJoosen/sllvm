Index: include/llvm/IR/CallingConv.h
===================================================================
--- include/llvm/IR/CallingConv.h	(revision 349308)
+++ include/llvm/IR/CallingConv.h	(working copy)
@@ -223,6 +223,10 @@
     // Calling convention between AArch64 Advanced SIMD functions
     AArch64_VectorCall = 97,
 
+    /// Calling convention used for Sancus entry functions.
+    SANCUS_ENTRY = 97,
+    SANCUS_DISPATCH = 98,
+
     /// The highest possible calling convention ID. Must be some 2^k - 1.
     MaxID = 1023
   };
Index: include/llvm/IR/Intrinsics.td
===================================================================
--- include/llvm/IR/Intrinsics.td	(revision 349308)
+++ include/llvm/IR/Intrinsics.td	(working copy)
@@ -1132,6 +1132,15 @@
 
 def int_ssa_copy : Intrinsic<[llvm_any_ty], [LLVMMatchType<0>],
                              [IntrNoMem, Returned<0>]>;
+
+//===----- SLLVM intrinsics ----------------------------------------------===//
+
+def int_sllvm_eenter : Intrinsic<[], []>;  // Enter enclave entry point
+def int_sllvm_eexit : Intrinsic<[], []>;   // Exit enclave entry point
+def int_sllvm_excall : Intrinsic<[], []>;  // Enclave exit calls
+def int_sllvm_eresume : Intrinsic<[], []>; // Resume from enclave exit call
+def int_sllvm_attest : Intrinsic<[], []>;  // Attest protected module
+
 //===----------------------------------------------------------------------===//
 // Target-specific intrinsics
 //===----------------------------------------------------------------------===//
Index: lib/Support/GraphWriter.cpp
===================================================================
--- lib/Support/GraphWriter.cpp	(revision 349308)
+++ lib/Support/GraphWriter.cpp	(working copy)
@@ -153,6 +153,19 @@
   std::string ViewerPath;
   GraphSession S;
 
+  // xdot
+  if (S.TryFindProgram("xdot|xdot.py", ViewerPath)) {
+    std::vector<StringRef> args;
+    args.push_back(ViewerPath);
+    args.push_back(Filename);
+
+    args.push_back("-f");
+    args.push_back(getProgramName(program));
+
+    errs() << "Running 'xdot.py' program... ";
+    return ExecGraphViewer(ViewerPath, args, Filename, wait, ErrMsg);
+  }
+
 #ifdef __APPLE__
   wait &= !ViewBackground;
   if (S.TryFindProgram("open", ViewerPath)) {
@@ -185,19 +198,6 @@
     return ExecGraphViewer(ViewerPath, args, Filename, wait, ErrMsg);
   }
 
-  // xdot
-  if (S.TryFindProgram("xdot|xdot.py", ViewerPath)) {
-    std::vector<StringRef> args;
-    args.push_back(ViewerPath);
-    args.push_back(Filename);
-
-    args.push_back("-f");
-    args.push_back(getProgramName(program));
-
-    errs() << "Running 'xdot.py' program... ";
-    return ExecGraphViewer(ViewerPath, args, Filename, wait, ErrMsg);
-  }
-
   enum ViewerKind {
     VK_None,
     VK_OSXOpen,
Index: lib/Target/MSP430/CMakeLists.txt
===================================================================
--- lib/Target/MSP430/CMakeLists.txt	(revision 349308)
+++ lib/Target/MSP430/CMakeLists.txt	(working copy)
@@ -14,6 +14,7 @@
 
 add_llvm_target(MSP430CodeGen
   MSP430BranchSelector.cpp
+  MSP430RTLInternalizer.cpp
   MSP430ISelDAGToDAG.cpp
   MSP430ISelLowering.cpp
   MSP430InstrInfo.cpp
Index: lib/Target/MSP430/MSP430.h
===================================================================
--- lib/Target/MSP430/MSP430.h	(revision 349308)
+++ lib/Target/MSP430/MSP430.h	(working copy)
@@ -42,6 +42,7 @@
   FunctionPass *createMSP430ISelDag(MSP430TargetMachine &TM,
                                     CodeGenOpt::Level OptLevel);
 
+  FunctionPass *createMSP430RTLInternalizationPass();
   FunctionPass *createMSP430BranchSelectionPass();
 
 } // end namespace llvm;
Index: lib/Target/MSP430/MSP430AsmPrinter.cpp
===================================================================
--- lib/Target/MSP430/MSP430AsmPrinter.cpp	(revision 349308)
+++ lib/Target/MSP430/MSP430AsmPrinter.cpp	(working copy)
@@ -14,6 +14,8 @@
 
 #include "InstPrinter/MSP430InstPrinter.h"
 #include "MSP430.h"
+#include "llvm/SLLVM.h"
+#include "MSP430Sancus.h"
 #include "MSP430InstrInfo.h"
 #include "MSP430MCInstLower.h"
 #include "MSP430TargetMachine.h"
@@ -54,11 +56,31 @@
     bool PrintAsmMemoryOperand(const MachineInstr *MI,
                                unsigned OpNo, unsigned AsmVariant,
                                const char *ExtraCode, raw_ostream &O) override;
+
+    void EmitEndOfAsmFile(Module &) override;
+
     void EmitInstruction(const MachineInstr *MI) override;
   };
 } // end of anonymous namespace
 
+void MSP430AsmPrinter::EmitEndOfAsmFile(Module &M) {
+  if (sllvm::isPM(&M)) {
+    // TODO: Have section names generated
+    // TODO: Use OutStreamer.setSection, pushSection or something similar
+    OutStreamer->EmitRawText(
+        "\t.section\t.sllvm.text." + sllvm::getPMName(&M) + ",\"ax\",@progbits");
+    OutStreamer->EmitRawText(sllvm::sancus::asm_eenter);
+    OutStreamer->EmitRawText(sllvm::sancus::asm_eexit);
+    OutStreamer->EmitRawText(sllvm::sancus::asm_excall);
+    OutStreamer->EmitRawText(sllvm::sancus::asm_eresume);
+    OutStreamer->EmitRawText(sllvm::sancus::asm_attest);
 
+    // TODO: Use OutStreamer.setSection, pushSection or something similar
+    OutStreamer->EmitRawText("\t.text");
+    //OutStreamer->EmitRawText(sllvm::sancus::asm_protect);
+  }
+}
+
 void MSP430AsmPrinter::printOperand(const MachineInstr *MI, int OpNum,
                                     raw_ostream &O, const char *Modifier) {
   const MachineOperand &MO = MI->getOperand(OpNum);
Index: lib/Target/MSP430/MSP430ISelLowering.cpp
===================================================================
--- lib/Target/MSP430/MSP430ISelLowering.cpp	(revision 349308)
+++ lib/Target/MSP430/MSP430ISelLowering.cpp	(working copy)
@@ -13,12 +13,15 @@
 
 #include "MSP430ISelLowering.h"
 #include "MSP430.h"
+#include "MSP430Sancus.h"
 #include "MSP430MachineFunctionInfo.h"
 #include "MSP430Subtarget.h"
 #include "MSP430TargetMachine.h"
+#include "llvm/SLLVM.h"
 #include "llvm/CodeGen/CallingConvLower.h"
 #include "llvm/CodeGen/MachineFrameInfo.h"
 #include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineModuleInfo.h"
 #include "llvm/CodeGen/MachineInstrBuilder.h"
 #include "llvm/CodeGen/MachineRegisterInfo.h"
 #include "llvm/CodeGen/SelectionDAGISel.h"
@@ -436,26 +439,47 @@
 static void AnalyzeArguments(CCState &State,
                              SmallVectorImpl<CCValAssign> &ArgLocs,
                              const SmallVectorImpl<ArgT> &Args) {
-  static const MCPhysReg CRegList[] = {
-    MSP430::R12, MSP430::R13, MSP430::R14, MSP430::R15
-  };
-  static const unsigned CNbRegs = array_lengthof(CRegList);
-  static const MCPhysReg BuiltinRegList[] = {
-    MSP430::R8, MSP430::R9, MSP430::R10, MSP430::R11,
-    MSP430::R12, MSP430::R13, MSP430::R14, MSP430::R15
-  };
-  static const unsigned BuiltinNbRegs = array_lengthof(BuiltinRegList);
+  if (State.getCallingConv() == CallingConv::SANCUS_DISPATCH)
+    return;
 
   ArrayRef<MCPhysReg> RegList;
   unsigned NbRegs;
 
-  bool Builtin = (State.getCallingConv() == CallingConv::MSP430_BUILTIN);
-  if (Builtin) {
-    RegList = BuiltinRegList;
-    NbRegs = BuiltinNbRegs;
-  } else {
-    RegList = CRegList;
-    NbRegs = CNbRegs;
+  switch (State.getCallingConv()) {
+    default:
+      report_fatal_error("Unsupported calling convention");
+    case CallingConv::MSP430_BUILTIN:
+      {
+        static const MCPhysReg BuiltinRegList[] = {
+          MSP430::R8, MSP430::R9, MSP430::R10, MSP430::R11,
+          MSP430::R12, MSP430::R13, MSP430::R14, MSP430::R15
+        };
+        static const unsigned BuiltinNbRegs = array_lengthof(BuiltinRegList);
+        RegList = BuiltinRegList;
+        NbRegs = BuiltinNbRegs;
+      }
+      break;
+    case CallingConv::Fast:
+    case CallingConv::C:
+      {
+        static const MCPhysReg CRegList[] = {
+          MSP430::R12, MSP430::R13, MSP430::R14, MSP430::R15
+        };
+        static const unsigned CNbRegs = array_lengthof(CRegList);
+        RegList = CRegList;
+        NbRegs = CNbRegs;
+      }
+      break;
+    case CallingConv::SANCUS_ENTRY:
+      {
+        static const MCPhysReg SRegList[] = {
+          MSP430::R6, MSP430::R12, MSP430::R13, MSP430::R14, MSP430::R15
+        };
+        static const unsigned SNbRegs = array_lengthof(SRegList);
+        RegList = SRegList;
+        NbRegs = SNbRegs;
+      }
+      break;
   }
 
   if (State.isVarArg()) {
@@ -466,6 +490,7 @@
   SmallVector<unsigned, 4> ArgsParts;
   ParseFunctionArgs(Args, ArgsParts);
 
+  bool Builtin = (State.getCallingConv() == CallingConv::MSP430_BUILTIN);
   if (Builtin) {
     assert(ArgsParts.size() == 2 &&
         "Builtin calling convention requires two arguments");
@@ -554,6 +579,8 @@
     report_fatal_error("Unsupported calling convention");
   case CallingConv::C:
   case CallingConv::Fast:
+  case CallingConv::SANCUS_ENTRY:
+  case CallingConv::SANCUS_DISPATCH:
     return LowerCCCArguments(Chain, CallConv, isVarArg, Ins, dl, DAG, InVals);
   case CallingConv::MSP430_INTR:
     if (Ins.empty())
@@ -585,7 +612,9 @@
   case CallingConv::MSP430_BUILTIN:
   case CallingConv::Fast:
   case CallingConv::C:
-    return LowerCCCCallTo(Chain, Callee, CallConv, isVarArg, isTailCall,
+  case CallingConv::SANCUS_ENTRY:
+  case CallingConv::SANCUS_DISPATCH:
+    return LowerCCCCallTo(CLI, Chain, Callee, CallConv, isVarArg, isTailCall,
                           Outs, OutVals, Ins, dl, DAG, InVals);
   case CallingConv::MSP430_INTR:
     report_fatal_error("ISRs cannot be called directly");
@@ -779,9 +808,173 @@
   return DAG.getNode(Opc, dl, MVT::Other, RetOps);
 }
 
+SDValue MSP430TargetLowering::saveStack(SDValue Chain,
+                                        const SDLoc &dl,
+                                        SelectionDAG &DAG,
+                                        const Module *M,
+                                        StringRef gName) const {
+  auto PtrVT = getPointerTy(DAG.getDataLayout());
+  GlobalVariable * GV = M->getGlobalVariable(gName, true);
+  assert (GV != nullptr);
+  SDValue GA = DAG.getGlobalAddress(GV, dl, MVT::i16);
+  SDValue SP = DAG.getRegister(MSP430::SP, PtrVT);
+  return DAG.getStore(Chain, dl, SP, GA, MachinePointerInfo());
+}
+
+SDValue MSP430TargetLowering::restoreStack(SDValue Chain,
+                                           const SDLoc &dl,
+                                           SelectionDAG &DAG,
+                                           const Module *M,
+                                           StringRef gName) const {
+  auto PtrVT = getPointerTy(DAG.getDataLayout());
+  GlobalVariable *GV = M->getGlobalVariable(gName, true);
+  assert(GV != nullptr);
+  // TODO: Is MVT::i16 type correct (and all the others that I used) ?
+  SDValue G = DAG.getGlobalAddress(GV, dl, PtrVT);
+  SDValue L = DAG.getLoad(PtrVT, dl, Chain, G, MachinePointerInfo());
+  return DAG.getCopyToReg(Chain, dl, MSP430::SP, L);
+}
+
+SDValue MSP430TargetLowering::pushOnStack(SDValue Chain,
+                                         const SDLoc &dl,
+                                         SelectionDAG &DAG,
+                                         SDValue V) const {
+  // TODO: Isn't there a simpler way (like just a simple push...)?
+  //        (and why can't we add directly to the register?)
+  auto PtrVT = getPointerTy(DAG.getDataLayout());
+  SDValue Size = DAG.getIntPtrConstant(2, dl);
+  SDValue OldSP = DAG.getCopyFromReg(Chain, dl, MSP430::SP, PtrVT);
+  SDValue NewSP = DAG.getNode(ISD::SUB, dl, PtrVT, OldSP, Size);
+  Chain = DAG.getCopyToReg(Chain, dl, MSP430::SP, NewSP);
+  SDValue SP = DAG.getRegister(MSP430::SP, PtrVT);
+  return DAG.getStore(Chain, dl, V, SP, MachinePointerInfo());
+}
+
+// TODO: Move (part of it) to SLLVM.h
+static bool isEXCallToUnprotecedCode(TargetLowering::CallLoweringInfo &CLI) {
+  if (CLI.CS.getInstruction() == nullptr)
+    return false;
+  const Module * M = CLI.CS.getCaller()->getParent();
+  if (sllvm::isPM(M)) {
+    if (CLI.CS.getCaller()->hasLocalLinkage()) { // Not for public functions
+      const Function *CF = CLI.CS.getCalledFunction();
+      assert (CF != nullptr && "Indirect calls are not allowed in enclaves");
+      return (CLI.CallConv != CallingConv::SANCUS_ENTRY) && CF->isDeclaration();
+    }
+  }
+  return false;
+}
+
+// TODO: - Not sure if this is the right place to put this...
+//       - Maybe part of the logic related to R7 can be integrated in 
+//           AnalyzeArguments()
+//       - Refactor/Document !
+SDValue MSP430TargetLowering::lowerSancusCall(
+    CallLoweringInfo &CLI,
+    SDValue Chain,
+    const SDLoc &dl,
+    SelectionDAG &DAG) const {
+
+  if (CLI.CS.getInstruction() == nullptr)
+    return Chain;
+
+  const Module * M = CLI.CS.getCaller()->getParent();
+
+  if ( (! sllvm::isPM(M)) && (CLI.CallConv != CallingConv::SANCUS_ENTRY) )
+    return Chain;
+
+  if (  (! CLI.CS.getCaller()->hasLocalLinkage()) // Not for public functions
+     && (CLI.CallConv != CallingConv::SANCUS_ENTRY) )
+    return Chain;
+
+  auto PtrVT = getPointerTy(DAG.getDataLayout());
+
+  // Retrieve the after-call-label (ACL)
+  MachineFunction &MF = DAG.getMachineFunction();
+  MCSymbol *Sym = MF.getMMI().getContext().createDirectionalLocalSymbol(0);
+  SDValue ACL = DAG.getMCSymbol(Sym, PtrVT);
+
+  if (sllvm::isPM(M) && CLI.CS.getCaller()->hasLocalLinkage()) {
+    const Function *CF = CLI.CS.getCalledFunction();
+    assert (CF != nullptr && "Indirect calls are not allowed in enclaves");
+
+    // Retrieve the dispatcher
+    Function *F = M->getFunction(sllvm::sancus::fname_dispatch);
+    assert (F != nullptr && "Enclave dispatcher not found");
+    SDValue D = DAG.getGlobalAddress(F, dl, MVT::i16);
+
+    if (CLI.CallConv == CallingConv::SANCUS_ENTRY) {
+      assert (CF->isDeclaration() && "External call expected");
+      Chain = DAG.getCopyToReg(Chain, dl, MSP430::R7, D);
+    }
+
+    if (CF->isDeclaration()) {  // Ignore internal calls
+      Chain = pushOnStack(Chain, dl, DAG, ACL);
+      Chain = saveStack(Chain, dl, DAG, M, sllvm::sancus::local_r1);
+    }
+
+    if (isEXCallToUnprotecedCode(CLI)) {
+      Chain = restoreStack(Chain, dl, DAG, M, sllvm::sancus::global_r1);
+      Chain = pushOnStack(Chain, dl, DAG, D);
+      SDValue C = DAG.getConstant(sllvm::sancus::R6_URet, dl, MVT::i16);
+      Chain = DAG.getCopyToReg(Chain, dl, MSP430::R6, C);
+    }
+  }
+  else {
+    if (CLI.CallConv == CallingConv::SANCUS_ENTRY) {
+#if 0
+      Chain = DAG.getCopyToReg(Chain, dl, MSP430::R7, ACL);
+#else
+      // TODO: Find out why the simple code above asserts (Compiler bug?)
+      GlobalVariable *GV = M->getGlobalVariable(sllvm::sancus::global_pc, true);
+      assert(GV != nullptr);
+      SDValue G = DAG.getGlobalAddress(GV, dl, MVT::i16);
+      Chain = DAG.getStore(Chain, dl, ACL, G, MachinePointerInfo());
+
+      SDValue L = DAG.getLoad(PtrVT, dl, Chain, G, MachinePointerInfo());
+      Chain = DAG.getCopyToReg(Chain, dl, MSP430::R7, L);
+#endif
+
+      Chain = saveStack(Chain, dl, DAG, M, sllvm::sancus::global_r1);
+    }
+  }
+
+  return Chain;
+}
+
+// TODO: Document/Refactor
+SDValue MSP430TargetLowering::LowerSancusCallResult(
+    CallLoweringInfo &CLI,
+    SDValue Chain,
+    const SDLoc &dl,
+    SelectionDAG &DAG) const {
+
+  if (CLI.CS.getInstruction() == nullptr)
+    return Chain;
+
+  const Module * M = CLI.CS.getCaller()->getParent();
+  const Function *CF = CLI.CS.getCalledFunction();
+
+  if ( (CLI.CallConv == CallingConv::SANCUS_ENTRY)
+      || ( sllvm::isPM(M) && CLI.CS.getCaller()->hasLocalLinkage() && (CF != nullptr) && CF->isDeclaration() ) ) {
+
+    // Generate the after-call-label (ACL)
+    MachineFunction &MF = DAG.getMachineFunction();
+    MCSymbol *ACL = MF.getMMI().getContext().getDirectionalLocalSymbol(0, true);
+    Chain = DAG.getLabelNode(ISD::ANNOTATION_LABEL, dl, Chain, ACL);
+
+    if (! (sllvm::isPM(M) && CLI.CS.getCaller()->hasLocalLinkage()) ) {
+      Chain = restoreStack(Chain, dl, DAG, M, sllvm::sancus::global_r1);
+    }
+  }
+
+  return Chain;
+}
+
 /// LowerCCCCallTo - functions arguments are copied from virtual regs to
 /// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.
 SDValue MSP430TargetLowering::LowerCCCCallTo(
+    TargetLowering::CallLoweringInfo &CLI,
     SDValue Chain, SDValue Callee, CallingConv::ID CallConv, bool isVarArg,
     bool isTailCall, const SmallVectorImpl<ISD::OutputArg> &Outs,
     const SmallVectorImpl<SDValue> &OutVals,
@@ -797,6 +990,8 @@
   unsigned NumBytes = CCInfo.getNextStackOffset();
   auto PtrVT = getPointerTy(DAG.getDataLayout());
 
+  Chain = lowerSancusCall(CLI, Chain, dl, DAG);
+
   Chain = DAG.getCALLSEQ_START(Chain, NumBytes, 0, dl);
 
   SmallVector<std::pair<unsigned, SDValue>, 4> RegsToPass;
@@ -893,10 +1088,19 @@
     Ops.push_back(DAG.getRegister(RegsToPass[i].first,
                                   RegsToPass[i].second.getValueType()));
 
+  // R7 is live into Sancus entry calls
+  if (CLI.CallConv == CallingConv::SANCUS_ENTRY)
+      Ops.push_back(DAG.getRegister(MSP430::R7, PtrVT));
+
   if (InFlag.getNode())
     Ops.push_back(InFlag);
-
-  Chain = DAG.getNode(MSP430ISD::CALL, dl, NodeTys, Ops);
+  
+  if (isEXCallToUnprotecedCode(CLI)) {
+    Chain = DAG.getNode(MSP430ISD::BRCALL, dl, NodeTys, Ops);
+  } 
+  else {
+    Chain = DAG.getNode(MSP430ISD::CALL, dl, NodeTys, Ops);
+  }
   InFlag = Chain.getValue(1);
 
   // Create the CALLSEQ_END node.
@@ -906,8 +1110,10 @@
 
   // Handle result values, copying them out of physregs into vregs that we
   // return.
-  return LowerCallResult(Chain, InFlag, CallConv, isVarArg, Ins, dl,
-                         DAG, InVals);
+  Chain = LowerCallResult(CLI, Chain, InFlag, CallConv, isVarArg, Ins, dl,
+                          DAG, InVals);
+
+  return Chain;
 }
 
 /// LowerCallResult - Lower the result values of a call into the
@@ -914,6 +1120,7 @@
 /// appropriate copies out of appropriate physical registers.
 ///
 SDValue MSP430TargetLowering::LowerCallResult(
+    TargetLowering::CallLoweringInfo &CLI,
     SDValue Chain, SDValue InFlag, CallingConv::ID CallConv, bool isVarArg,
     const SmallVectorImpl<ISD::InputArg> &Ins, const SDLoc &dl,
     SelectionDAG &DAG, SmallVectorImpl<SDValue> &InVals) const {
@@ -933,6 +1140,8 @@
     InVals.push_back(Chain.getValue(0));
   }
 
+  Chain = LowerSancusCallResult(CLI, Chain, dl, DAG);
+
   return Chain;
 }
 
@@ -1348,6 +1557,7 @@
   case MSP430ISD::RRC:                return "MSP430ISD::RRC";
   case MSP430ISD::RRCL:               return "MSP430ISD::RRCL";
   case MSP430ISD::CALL:               return "MSP430ISD::CALL";
+  case MSP430ISD::BRCALL:             return "MSP430ISD::BRCALL";
   case MSP430ISD::Wrapper:            return "MSP430ISD::Wrapper";
   case MSP430ISD::BR_CC:              return "MSP430ISD::BR_CC";
   case MSP430ISD::CMP:                return "MSP430ISD::CMP";
Index: lib/Target/MSP430/MSP430ISelLowering.h
===================================================================
--- lib/Target/MSP430/MSP430ISelLowering.h	(revision 349308)
+++ lib/Target/MSP430/MSP430ISelLowering.h	(working copy)
@@ -43,6 +43,9 @@
       /// instruction, which includes a bunch of information.
       CALL,
 
+      /// BRCALL - Behaves like a call put does not push the return address
+      BRCALL,
+
       /// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,
       /// and TargetGlobalAddress.
       Wrapper,
@@ -132,7 +135,19 @@
                                       MachineBasicBlock *BB) const;
 
   private:
-    SDValue LowerCCCCallTo(SDValue Chain, SDValue Callee,
+    SDValue saveStack(SDValue Chain, const SDLoc &dl, SelectionDAG &DAG,
+                      const Module *M, StringRef gName) const;
+    SDValue restoreStack(SDValue Chain, const SDLoc &dl, SelectionDAG &DAG,
+                         const Module *M, StringRef gName) const;
+    SDValue pushOnStack(SDValue Chain, const SDLoc &dl, SelectionDAG &DAG,
+                       SDValue V) const;
+    SDValue lowerSancusCall(CallLoweringInfo &CLI, SDValue Chain,
+                            const SDLoc &dl, SelectionDAG &DAG) const;
+    SDValue LowerSancusCallResult(CallLoweringInfo &CLI, SDValue Chain,
+                                  const SDLoc &dl, SelectionDAG &DAG) const;
+
+    SDValue LowerCCCCallTo(CallLoweringInfo &CLI,
+                           SDValue Chain, SDValue Callee,
                            CallingConv::ID CallConv, bool isVarArg,
                            bool isTailCall,
                            const SmallVectorImpl<ISD::OutputArg> &Outs,
@@ -147,7 +162,8 @@
                               const SDLoc &dl, SelectionDAG &DAG,
                               SmallVectorImpl<SDValue> &InVals) const;
 
-    SDValue LowerCallResult(SDValue Chain, SDValue InFlag,
+    SDValue LowerCallResult(CallLoweringInfo &CLI,
+                            SDValue Chain, SDValue InFlag,
                             CallingConv::ID CallConv, bool isVarArg,
                             const SmallVectorImpl<ISD::InputArg> &Ins,
                             const SDLoc &dl, SelectionDAG &DAG,
Index: lib/Target/MSP430/MSP430InstrInfo.cpp
===================================================================
--- lib/Target/MSP430/MSP430InstrInfo.cpp	(revision 349308)
+++ lib/Target/MSP430/MSP430InstrInfo.cpp	(working copy)
@@ -314,6 +314,13 @@
     return TII.getInlineAsmLength(MI.getOperand(0).getSymbolName(),
                                   *MF->getTarget().getMCAsmInfo());
   }
+  case MSP430::eexit:
+  case MSP430::eenter:
+  case MSP430::excall:
+  case MSP430::eresume:
+  case MSP430::attest:
+    // TODO: Not sure what ... (but code asserts when case is left out)
+    return 12;
   }
 
   return Desc.getSize();
Index: lib/Target/MSP430/MSP430InstrInfo.td
===================================================================
--- lib/Target/MSP430/MSP430InstrInfo.td	(revision 349308)
+++ lib/Target/MSP430/MSP430InstrInfo.td	(working copy)
@@ -53,6 +53,8 @@
 
 def MSP430call    : SDNode<"MSP430ISD::CALL", SDT_MSP430Call,
                      [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue, SDNPVariadic]>;
+def MSP430brcall  : SDNode<"MSP430ISD::BRCALL", SDT_MSP430Call,
+                     [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue, SDNPVariadic]>;
 def MSP430callseq_start :
                  SDNode<"ISD::CALLSEQ_START", SDT_MSP430CallSeqStart,
                         [SDNPHasChain, SDNPOutGlue]>;
@@ -223,6 +225,46 @@
 }
 
 //===----------------------------------------------------------------------===//
+//  SLLVM instructions
+//
+
+let isCodeGenOnly = 1 in {
+def eenter : Pseudo<(outs), (ins),
+                    // In case this is a return from a call to unprotected code,
+                    //  the sp should be saved before switching stacks
+                    // TODO: Is it better to do this at DAG level ?
+                    //          (see X86 for example)
+                    "cmp\t#0xfffe, r6\n\t"
+                    "jne\t1f\n\t"
+                    "mov\tr1, &sllvm_r1\n"
+                    "1:\n\t"
+                    // Switch stack
+                    "mov\t&sllvm_lr1, r1\n\t"
+                    "call\t#sllvm_eenter"
+                    ,[(int_sllvm_eenter)]>;
+
+def eexit : Pseudo<(outs), (ins),
+                   "call\t#sllvm_eexit\n\t"
+                   // Save stack
+                   "mov\tr1, &sllvm_lr1\n\t"
+                   // Push return address
+                   "push\tr7"
+                   ,[(int_sllvm_eexit)]>;
+}
+
+def excall : Pseudo<(outs), (ins),
+                   "call\t#sllvm_excall"
+                   ,[(int_sllvm_excall)]>;
+
+def eresume : Pseudo<(outs), (ins),
+                   "call\t#sllvm_eresume"
+                   ,[(int_sllvm_eresume)]>;
+                   
+def attest : Pseudo<(outs), (ins),
+                   "call\t#sllvm_attest"
+                   ,[(int_sllvm_attest)]>;
+
+//===----------------------------------------------------------------------===//
 //  Control Flow Instructions...
 //
 
@@ -292,6 +334,15 @@
   def CALLm     : II16m<0b101,
                         (outs), (ins memsrc:$src),
                         "call\t$src", [(MSP430call (load addr:$src))]>;
+  def BRCALLi   : II16i<0b101,
+                        (outs), (ins i16imm:$imm),
+                        "br\t$imm", [(MSP430brcall imm:$imm)]>;
+  def BRCALLr   : II16r<0b101,
+                        (outs), (ins GR16:$rs),
+                        "br\t$rs", [(MSP430brcall GR16:$rs)]>;
+  def BRCALLm   : II16m<0b101,
+                        (outs), (ins memsrc:$src),
+                        "br\t$src", [(MSP430brcall (load addr:$src))]>;
 }
 
 //===----------------------------------------------------------------------===//
Index: lib/Target/MSP430/MSP430MCInstLower.cpp
===================================================================
--- lib/Target/MSP430/MSP430MCInstLower.cpp	(revision 349308)
+++ lib/Target/MSP430/MSP430MCInstLower.cpp	(working copy)
@@ -142,6 +142,9 @@
     case MachineOperand::MO_ExternalSymbol:
       MCOp = LowerSymbolOperand(MO, GetExternalSymbolSymbol(MO));
       break;
+    case MachineOperand::MO_MCSymbol:
+      MCOp = LowerSymbolOperand(MO, MO.getMCSymbol());
+      break;
     case MachineOperand::MO_JumpTableIndex:
       MCOp = LowerSymbolOperand(MO, GetJumpTableSymbol(MO));
       break;
Index: lib/Target/MSP430/MSP430TargetMachine.cpp
===================================================================
--- lib/Target/MSP430/MSP430TargetMachine.cpp	(revision 349308)
+++ lib/Target/MSP430/MSP430TargetMachine.cpp	(working copy)
@@ -80,6 +80,7 @@
 }
 
 void MSP430PassConfig::addPreEmitPass() {
+  addPass(createMSP430RTLInternalizationPass(), false);
   // Must run branch selection immediately preceding the asm printer.
   addPass(createMSP430BranchSelectionPass(), false);
 }
